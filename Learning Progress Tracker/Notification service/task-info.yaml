type: edu
files:
- name: src/tracker/Main.java
  visible: true
  text: |
    package tracker;

    public class Main {
        public static void main(String[] args) {
            System.out.println("Hello, World!");
        }
    }
  learner_created: false
- name: build.gradle
  visible: true
  text: |
    repositories {
        mavenCentral()
    }

    dependencies {
        testImplementation 'org.junit.jupiter:junit-jupiter:5.7.1'
        testRuntimeOnly 'org.junit.vintage:junit-vintage-engine:5.7.1'
    }

    test {
        useJUnitPlatform()
    }
  learner_created: false
- name: test/tracker/SampleTest.java
  visible: true
  text: |
    package tracker;

    import org.junit.jupiter.api.Test;

    import static org.junit.jupiter.api.Assertions.*;

    public class SampleTest {

        @Test
        void test() {
            assertEquals(5, 2 + 3);
        }
    }
  learner_created: false
- name: test/LearningProgressTrackerTest.java
  visible: false
  text: |
    import org.hyperskill.hstest.dynamic.DynamicTest;
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
    import org.hyperskill.hstest.stage.StageTest;
    import org.hyperskill.hstest.testcase.CheckResult;
    import org.hyperskill.hstest.testing.TestedProgram;

    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.Collections;
    import java.util.HashSet;
    import java.util.List;
    import java.util.Random;
    import java.util.Set;
    import java.util.function.Predicate;
    import java.util.stream.Collectors;
    import java.util.stream.IntStream;
    import java.util.stream.Stream;

    import static org.hyperskill.hstest.testing.expect.Expectation.expect;

    public class LearningProgressTrackerTest extends StageTest<String> {
        private static final Random rnd = new Random();

        @DynamicTest(order = 1)
        CheckResult testStartAndExit() {
            TestedProgram main = new TestedProgram();
            String output = main.start();
            expect(output).toContain(1).lines();
            if (incorrectString(output, "Learning Progress Tracker")) {
                return CheckResult.wrong("When started, your program " +
                        "should print \"Learning Progress Tracker\"");
            }

            if (!main.isWaitingInput()) {
                return CheckResult.wrong("After the start, your program should " +
                        "be ready to accept commands from the user");
            }

            output = main.execute("back");
            expect(output).toContain(1).lines();
            if (!main.isWaitingInput()) {
                return CheckResult.wrong("Your program should keep running after the 'back' " +
                        "command is entered");
            }

            if (anyMissingKeywords(output, "enter", "exit", "program")) {
                return CheckResult.wrong("When 'back' command is entered your program " +
                        "should print the hint \"Enter 'exit' to exit the program.\"");
            }

            output = main.execute("exit");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "bye")) {
                return CheckResult.wrong("When the 'exit' command is entered, " +
                        "your program should say bye to the user");
            }

            if (!main.isFinished()) {
                return CheckResult.wrong("After the 'exit' command has been entered, " +
                        "your program should stop working");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 2, data = "getBlankInput")
        CheckResult testBlankInput(String input) {
            TestedProgram main = new TestedProgram();
            main.start();

            String output = main.execute(input);
            expect(output).toContain(1).lines();
            if (incorrectString(output, "no input")) {
                return CheckResult.wrong("When the user enters an empty or blank " +
                        "string, your program should print \"No input.\"");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 3, data = "getUnknownCommands")
        CheckResult testUnknownCommands(String input) {
            TestedProgram main = new TestedProgram();
            main.start();

            String output = main.execute(input);
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "unknown", "command")) {
                return CheckResult.wrong("When an unknown command is entered, your " +
                        "program should display an error message: \"Unknown command!\"");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 4)
        CheckResult testAddStudents1() {
            TestedProgram main = new TestedProgram();
            main.start();

            String output = main.execute("add students");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output,
                    "enter", "student", "credentials", "back", "return")) {
                return CheckResult.wrong("When 'add students' command is entered, your " +
                        "program should display the prompt \"Enter student credentials or " +
                        "'back' to return:\"");
            }

            output = main.execute("exit");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "incorrect", "credentials")) {
                return CheckResult.wrong("Expected output: \"Incorrect credentials.\", " +
                        "but your output was: " + output);
            }

            output = main.execute("back");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "total", "0", "students", "added")) {
                return CheckResult.wrong("Expected: \"Total 0 students have been added.\", but " +
                        "your output was: " + output);
            }

            output = main.execute("back");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "enter", "exit", "program")) {
                return CheckResult.wrong("When 'back' command is entered your program " +
                        "should stop waiting for student credentials");
            }

            output = main.execute("exit");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "bye")) {
                return CheckResult.wrong("When the 'exit' command is entered, " +
                        "your program should say bye to the user");
            }

            if (!main.isFinished()) {
                return CheckResult.wrong("After the 'exit' command has been entered, " +
                        "your program should stop working");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 5)
        CheckResult testAddStudents2() {
            TestedProgram main = new TestedProgram();
            main.start();

            main.execute("add students");
            for (String input : getCorrectCredentials()) {
                String output = main.execute(input);
                expect(output).toContain(1).lines();
                if (anyMissingKeywords(output, "student", "added")) {
                    return CheckResult.wrong("Expected output: \"The student has been added.\", but your " +
                            "output was: " + output);
                }
            }

            String output = main.execute("back");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "total", "10", "students", "added")) {
                return CheckResult.wrong("Expected: \"Total 10 students have been added.\", but " +
                        "your output was: " + output);
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 6)
        CheckResult testAddStudents3() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");

            for (String[] args : getIncorrectCredentials()) {
                String output = main.execute(args[0]);
                expect(output).toContain(1).lines();
                if (incorrectString(output, args[1])) {
                    return CheckResult.wrong("Expected output: \"" + args[1] + "\", but your " +
                            "output was: " + output);
                }
            }

            String output = main.execute("back");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "total", "0", "students", "added")) {
                return CheckResult.wrong("Expected: \"Total 0 students have been added.\", but " +
                        "your output was: " + output);
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 7)
        CheckResult testFindAll1() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");
            main.execute("back");

            String output = main.execute("list");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "no", "found")) {
                return CheckResult.wrong("Expected: \"No students found.\", but " +
                        "your output was: " + output);
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 8)
        CheckResult testAddDoubles() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");

            List<String> credentials = getRandomCredentials(12);
            for (String arg : credentials) {
                String output = main.execute(arg);
                expect(output).toContain(1).lines();
                if (anyMissingKeywords(output, "student", "added")) {
                    return CheckResult.wrong("Expected output: \"The student has been added.\", but your " +
                            "output was: " + output);
                }

                output = main.execute(arg);
                expect(output).toContain(1).lines();
                if (anyMissingKeywords(output, "this", "email", "already", "taken")) {
                    return CheckResult.wrong("Expected output: \"This email is already taken.\", but your " +
                            "output was: " + output);
                }
            }

            String output = main.execute("back");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "total", String.valueOf(credentials.size()), "students", "added")) {
                return CheckResult.wrong("Expected: \"Total " + credentials.size() + "students have been added.\", but " +
                        "your output was: " + output);
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 9)
        CheckResult testFindAll2() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");

            List<String> credentials = getRandomCredentials(12);
            for (String arg : credentials) {
                String output = main.execute(arg);
                expect(output).toContain(1).lines();
                if (anyMissingKeywords(output, "student", "added")) {
                    main.stop();
                    return CheckResult.wrong("Expected output: \"The student has been added.\", but your " +
                            "output was: " + output);
                }
            }

            String output = main.execute("back");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "total", String.valueOf(credentials.size()), "students", "added")) {
                return CheckResult.wrong("Expected: \"Total " + credentials.size() + "students have been added.\", but " +
                        "your output was: " + output);
            }

            output = main.execute("list");
            List<String> lines = expect(output).toContain(credentials.size() + 1).lines();
            if (!lines.get(0).toLowerCase().contains("students")) {
                return CheckResult.wrong("Expected the header \"Students:\" but your first line was: " + lines.get(0));
            }

            List<String> ids = parseIds(lines);
            Set<String> uniqueIds = new HashSet<>(ids);
            if (uniqueIds.size() != ids.size()) {
                return CheckResult.wrong("Expected " + ids.size() +
                        " unique IDs but found only " + uniqueIds.size());
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 10)
        CheckResult testBackFromAddPoints() {
            TestedProgram main = new TestedProgram();
            main.start();

            String output = main.execute("add points");
            expect(output).toContain().lines();
            if (anyMissingKeywords(output, "enter", "id", "points", "back", "return")) {
                return CheckResult.wrong("When 'add points' command is entered, your program should print " +
                        "\"Enter an id and points or 'back' to return:\" but your output was: " + output);
            }

            main.execute("back");
            output = main.execute("back");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "enter", "exit", "program")) {
                return CheckResult.wrong("When 'back' command is entered your program " +
                        "should stop waiting for student id and points");
            }

            output = main.execute("exit");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "bye")) {
                return CheckResult.wrong("When the 'exit' command is entered, " +
                        "your program should say bye to the user");
            }

            if (!main.isFinished()) {
                return CheckResult.wrong("After the 'exit' command has been entered, " +
                        "your program should stop working");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 11)
        CheckResult testStudentPoints1() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");

            List<String> credentials = getRandomCredentials(6);
            for (String arg : credentials) {
                main.execute(arg);
            }

            main.execute("back");
            String output = main.execute("list");
            List<String> lines = expect(output).toContain().lines();
            List<String> ids = parseIds(lines);

            main.execute("add points");
            String[] points = getIncorrectPoints();
            for (String point : points) {
                output = main.execute(ids.get(0) + " " + point);
                expect(output).toContain().lines();
                if (anyMissingKeywords(output, "incorrect", "format")) {
                    return CheckResult.wrong("Expected output: \"Incorrect points format.\", but your output was: " + output);
                }
            }

            output = main.execute("imsurethereisnosuchstudentid 1 1 1 1");
            expect(output).toContain().lines();
            if (anyMissingKeywords(output, "no", "student", "found") ||
                    !output.contains("imsurethereisnosuchstudentid")) {
                return CheckResult.wrong("Expected output was: \"No student is found " +
                        "for id=imsurethereisnosuchstudentid.\" but your output was: " + output);
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 12)
        CheckResult testStudentPoints2() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");

            List<String> credentials = getRandomCredentials(6);
            for (String arg : credentials) {
                main.execute(arg);
            }
            main.execute("back");

            String output = main.execute("list");
            List<String> lines = expect(output).toContain().lines();
            List<String> ids = parseIds(lines);

            main.execute("add points");
            String[] points = getCorrectPoints(6);

            for (int i = 0; i < points.length; i++) {
                output = main.execute(ids.get(i) + " " + points[i]);
                expect(output).toContain(1).lines();
                if (anyMissingKeywords(output, "points", "updated")) {
                    return CheckResult.wrong("Expected \"Points updated.\" but your output was " + output);
                }
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 13)
        CheckResult testBackFromFind() {
            TestedProgram main = new TestedProgram();
            main.start();

            String output = main.execute("find");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "enter", "id", "back", "return")) {
                return CheckResult.wrong("When 'find' command is entered, you program should " +
                        "print \"Enter an id or 'back' to return:\", but your output was: " + output);
            }

            main.execute("back");
            output = main.execute("back");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "enter", "exit", "program")) {
                return CheckResult.wrong("When 'back' command is entered your program " +
                        "should stop waiting for student id");
            }

            output = main.execute("exit");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "bye")) {
                return CheckResult.wrong("When the 'exit' command is entered, " +
                        "your program should say bye to the user");
            }

            if (!main.isFinished()) {
                return CheckResult.wrong("After the 'exit' command has been entered, " +
                        "your program should stop working");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 14)
        CheckResult testFindByID() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");

            List<String> credentials = getRandomCredentials(5);
            for (String arg : credentials) {
                main.execute(arg);
            }
            main.execute("back");

            String output = main.execute("list");
            List<String> lines = expect(output).toContain().lines();
            List<String> ids = parseIds(lines);

            main.execute("add points");
            for (int i = 0; i < ids.size(); i++) {
                main.execute(String.format("%s %d %d %d %d", ids.get(i), i, i, i, i));
                main.execute(String.format("%s %d %d %d %d", ids.get(i), i, i, i, i));
            }

            main.execute("back");
            output = main.execute("find");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "enter", "id", "back", "return")) {
                return CheckResult.wrong("When 'find' command is entered, you program should " +
                        "print \"Enter an id or 'back' to return:\", but your output was: " + output);
            }

            for (int i = 0; i < ids.size(); i++) {
                output = main.execute(ids.get(i));
                expect(output).toContain(1).lines();
                String expected = String.format(
                        "%s points: Java=%d; DSA=%d; Databases=%d; Spring=%d",
                        ids.get(i), i * 2, i * 2, i * 2, i * 2
                );
                if (incorrectString(output, expected)) {
                    return CheckResult.wrong("Expected output: " + expected +
                            ", but your output was: " + output);
                }
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 15)
        CheckResult testBackFromStatistics() {
            TestedProgram main = new TestedProgram();
            main.start();

            String output = main.execute("statistics");
            main.execute("back");
            output = main.execute("back");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "enter", "exit", "program")) {
                return CheckResult.wrong("When 'back' command is entered your program " +
                        "should stop waiting for student id");
            }

            output = main.execute("exit");
            expect(output).toContain(1).lines();
            if (anyMissingKeywords(output, "bye")) {
                return CheckResult.wrong("When the 'exit' command is entered, " +
                        "your program should say bye to the user");
            }

            if (!main.isFinished()) {
                return CheckResult.wrong("After the 'exit' command has been entered, " +
                        "your program should stop working");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 16)
        CheckResult testStatistics1() {
            TestedProgram main = new TestedProgram();
            main.start();

            String output = main.execute("statistics");
            String[] lines = Arrays.stream(output.split("\n"))
                    .filter(Predicate.not(String::isBlank))
                    .toArray(String[]::new);

            if (anyMissingKeywords(lines[0], "course", "details", "back", "quit")) {
                return CheckResult.wrong("When the \"statistics\" command is entered, your " +
                        "program must print: \"Type the name of a course to see details or 'back' " +
                        "to quit:\", but your output was: " + lines[0]);
            }

            if (lines.length < 7) {
                return CheckResult.wrong("Your program should print a header and 6 " +
                        "categories, but you printed only " + lines.length + " lines");
            }

            List<String> categories = List.of("Most popular: n/a", "Least popular: n/a",
                    "Highest activity: n/a", "Lowest activity: n/a", "Easiest course: n/a",
                    "Hardest course: n/a");
            for (int i = 1; i < lines.length; i++) {
                if (incorrectString(lines[i], categories.get(i - 1))) {
                    return CheckResult.wrong("Expected: " + categories.get(i - 1) +
                            ", but your output was " + lines[i]);
                }
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 17)
        CheckResult testStatistics2() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("statistics");

            List<String> courses = List.of("Java", "DSA", "Databases", "Spring");
            for (String course : courses) {
                String output = main.execute(course);
                String[] lines = output.split("\n");
                if (lines.length < 2) {
                    return CheckResult.wrong("Expected 2 lines, but your output was only " + lines.length + " lines.");
                }

                if (incorrectString(lines[0], course.toLowerCase())) {
                    return CheckResult.wrong("Your first line should be " + course + ", but your output was " + lines[0]);
                }

                if (anyMissingKeywords(lines[1], "id", "points", "completed")) {
                    return CheckResult.wrong("Your second line should be \"id\tpoints\tcompleted\", " +
                            "but your output was " + lines[1]);
                }
            }

            List<String> unknown = Arrays.stream(getUnknownCommands())
                    .filter(str -> courses.stream().noneMatch(it -> it.trim().equalsIgnoreCase(str)))
                    .collect(Collectors.toList());

            for (String course : unknown) {
                String output = main.execute(course);
                if (incorrectString(output, "unknown course")) {
                    return CheckResult.wrong("Expected output: \"Unknown course.\", but your output was: " + output);
                }
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 18)
        CheckResult testStatistics3() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("statistics");

            main.execute("back");
            if (!main.isWaitingInput()) {
                return CheckResult.wrong("Your program should keep running after the 'back' " +
                        "command is entered");
            }

            String output = main.execute("back");
            if (anyMissingKeywords(output, "enter", "exit", "program")) {
                return CheckResult.wrong("When 'back' command is entered your program " +
                        "should print the hint \"Enter 'exit' to exit the program.\"");
            }

            output = main.execute("exit");
            if (anyMissingKeywords(output, "bye")) {
                return CheckResult.wrong("When the 'exit' command is entered, " +
                        "your program should say bye to the user");
            }

            if (!main.isFinished()) {
                return CheckResult.wrong("After the 'exit' command has been entered, " +
                        "your program should stop working");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 19)
        CheckResult testCategories1() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");

            getRandomCredentials(4).forEach(main::execute);

            main.execute("back");
            String output = main.execute("list");
            List<String> lines = expect(output).toContain().lines();
            List<String> ids = parseIds(lines);

            main.execute("add points");
            for (String id : ids) {
                main.execute(String.format("%s 5 4 3 1", id));
            }

            main.execute("back");
            lines = expect(main.execute("statistics")).toContain().lines();

            if (anyMissingKeywords(lines.get(1), "java", "dsa", "databases", "spring")) {
                return CheckResult.wrong("Expected most popular: Java, DSA, Databases, Spring, " +
                        "but your output was: " + lines.get(1));
            }

            if (!lines.get(2).toLowerCase().contains("n/a")) {
                return CheckResult.wrong("Expected least popular: n/a, " +
                        "but your output was: " + lines.get(2));
            }

            if (anyMissingKeywords(lines.get(3), "java", "dsa", "databases", "spring")) {
                return CheckResult.wrong("Expected top activity: Java, DSA, Databases, Spring, " +
                        "but your output was: " + lines.get(3));
            }

            if (!lines.get(4).contains("n/a")) {
                return CheckResult.wrong("Expected lowest activity: n/a, " +
                        "but your output was: " + lines.get(4));
            }

            if (anyMissingKeywords(lines.get(5), "java")) {
                return CheckResult.wrong("Expected easiest course: Java, " +
                        "but your output was: " + lines.get(5));
            }

            if (anyMissingKeywords(lines.get(6), "Spring")) {
                return CheckResult.wrong("Expected hardest course: Spring, " +
                        "but your output was: " + lines.get(6));
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 20)
        CheckResult testCategories2() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");

            getRandomCredentials(4).forEach(main::execute);

            main.execute("back");
            List<String> lines = expect(main.execute("list")).toContain().lines();
            List<String> ids = parseIds(lines);

            main.execute("add points");
            main.execute(String.format("%s 10 10 10 10", ids.get(0)));
            main.execute(String.format("%s 5 5 5 5", ids.get(1)));
            main.execute(String.format("%s 5 5 5 5", ids.get(2)));
            main.execute(String.format("%s 2 2 2 2", ids.get(3)));

            main.execute("back");
            main.execute("statistics");

            List<String> linesJava = expect(main.execute("Java")).toContain(6).lines();
            List<String> linesDsa = expect(main.execute("DSA")).toContain(6).lines();
            List<String> linesDb = expect(main.execute("Databases")).toContain(6).lines();
            List<String> linesSpring = expect(main.execute("Spring")).toContain(6).lines();

            if (!linesJava.get(2).matches(".+\\s+10\\s+1\\.7\\s?%.*") ||
                    !linesJava.get(3).matches(".+\\s+5\\s+0\\.8\\s?%.*") ||
                    !linesJava.get(4).matches(".+\\s+5\\s+0\\.8\\s?%.*") ||
                    !linesJava.get(5).matches(".+\\s+2\\s+0\\.3\\s?%.*") ||
                    !linesJava.get(2).startsWith(ids.get(0)) ||
                    !linesJava.get(3).startsWith(ids.get(1)) && !linesJava.get(3).startsWith(ids.get(2)) ||
                    !linesJava.get(4).startsWith(ids.get(1)) && !linesJava.get(4).startsWith(ids.get(2)) ||
                    !linesJava.get(5).startsWith(ids.get(3)) ||
                    linesJava.get(3).startsWith(ids.get(1)) && ids.get(1).compareTo(ids.get(2)) >= 0 ||
                    linesJava.get(3).startsWith(ids.get(2)) && ids.get(2).compareTo(ids.get(1)) >= 0) {
                return CheckResult.wrong("Your Java student list either contains incorrect data or is incorrectly sorted");
            }

            if (!linesDsa.get(2).matches(".+\\s+10\\s+2\\.5\\s?%.*") ||
                    !linesDsa.get(3).matches(".+\\s+5\\s+1\\.3\\s?%.*") ||
                    !linesDsa.get(4).matches(".+\\s+5\\s+1\\.3\\s?%.*") ||
                    !linesDsa.get(5).matches(".+\\s+2\\s+0\\.5\\s?%.*") ||
                    !linesDsa.get(2).startsWith(ids.get(0)) ||
                    !linesDsa.get(3).startsWith(ids.get(1)) && !linesDsa.get(3).startsWith(ids.get(2)) ||
                    !linesDsa.get(4).startsWith(ids.get(1)) && !linesDsa.get(4).startsWith(ids.get(2)) ||
                    !linesDsa.get(5).startsWith(ids.get(3)) ||
                    linesDsa.get(3).startsWith(ids.get(1)) && ids.get(1).compareTo(ids.get(2)) >= 0 ||
                    linesDsa.get(3).startsWith(ids.get(2)) && ids.get(2).compareTo(ids.get(1)) >= 0) {
                return CheckResult.wrong("Your DSA student list either contains incorrect data or is incorrectly sorted");
            }

            if (!linesDb.get(2).matches(".+\\s+10\\s+2\\.1\\s?%.*") ||
                    !linesDb.get(3).matches(".+\\s+5\\s+1\\.0\\s?%.*") ||
                    !linesDb.get(4).matches(".+\\s+5\\s+1\\.0\\s?%.*") ||
                    !linesDb.get(5).matches(".+\\s+2\\s+0\\.4\\s?%.*") ||
                    !linesDb.get(2).startsWith(ids.get(0)) ||
                    !linesDb.get(3).startsWith(ids.get(1)) && !linesDb.get(3).startsWith(ids.get(2)) ||
                    !linesDb.get(4).startsWith(ids.get(1)) && !linesDb.get(4).startsWith(ids.get(2)) ||
                    !linesDb.get(5).startsWith(ids.get(3)) ||
                    linesDb.get(3).startsWith(ids.get(1)) && ids.get(1).compareTo(ids.get(2)) >= 0 ||
                    linesDb.get(3).startsWith(ids.get(2)) && ids.get(2).compareTo(ids.get(1)) >= 0) {
                return CheckResult.wrong("Your Databases student list either contains incorrect data " +
                        "or is incorrectly sorted");
            }

            if (!linesSpring.get(2).matches(".+\\s+10\\s+1\\.8\\s?%.*") ||
                    !linesSpring.get(3).matches(".+\\s+5\\s+0\\.9\\s?%.*") ||
                    !linesSpring.get(4).matches(".+\\s+5\\s+0\\.9\\s?%.*") ||
                    !linesSpring.get(5).matches(".+\\s+2\\s+0\\.4\\s?%.*") ||
                    !linesSpring.get(2).startsWith(ids.get(0)) ||
                    !linesSpring.get(3).startsWith(ids.get(1)) && !linesSpring.get(3).startsWith(ids.get(2)) ||
                    !linesSpring.get(4).startsWith(ids.get(1)) && !linesSpring.get(4).startsWith(ids.get(2)) ||
                    !linesSpring.get(5).startsWith(ids.get(3)) ||
                    linesSpring.get(3).startsWith(ids.get(1)) && ids.get(1).compareTo(ids.get(2)) >= 0 ||
                    linesSpring.get(3).startsWith(ids.get(2)) && ids.get(2).compareTo(ids.get(1)) >= 0) {
                return CheckResult.wrong("Your Spring student list either contains incorrect data " +
                        "or is incorrectly sorted");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 21)
        CheckResult testCategories3() {
            TestedProgram main = new TestedProgram();
            main.start();
            main.execute("add students");

            main.execute("John Doe johnd@email.net");
            main.execute("Jane Spark jspark@yahoo.com");
            main.execute("back");

            List<String> lines = expect(main.execute("list")).toContain().lines();
            List<String> ids = parseIds(lines);

            main.execute("add points");
            main.execute(String.format("%s 8 7 7 5", ids.get(0)));
            main.execute(String.format("%s 7 6 9 7", ids.get(0)));
            main.execute(String.format("%s 6 5 5 0", ids.get(0)));
            main.execute(String.format("%s 8 0 8 6", ids.get(1)));
            main.execute(String.format("%s 7 0 0 0", ids.get(1)));
            main.execute(String.format("%s 9 0 0 5", ids.get(1)));

            main.execute("back");
            main.execute("statistics");

            List<String> linesJava = expect(main.execute("Java")).toContain(4).lines();
            List<String> linesDsa = expect(main.execute("DSA")).toContain(3).lines();
            List<String> linesDb = expect(main.execute("Databases")).toContain(4).lines();
            List<String> linesSpring = expect(main.execute("Spring")).toContain(4).lines();

            if (!linesJava.get(2).matches(".+\\s+24\\s+4\\.0\\s?%.*") ||
                    !linesJava.get(3).matches(".+\\s+21\\s+3\\.5\\s?%.*") ||
                    !linesJava.get(2).startsWith(ids.get(1)) || !linesJava.get(3).startsWith(ids.get(0))) {
                return CheckResult.wrong("Your Java student list either contains incorrect data or is incorrectly sorted");
            }

            if (!linesDsa.get(2).matches(".+\\s+18\\s+4\\.5\\s?%.*") || !linesDsa.get(2).startsWith(ids.get(0))) {
                return CheckResult.wrong("Your DSA student list either contains incorrect data or is incorrectly sorted");
            }

            if (!linesDb.get(2).matches(".+\\s+21\\s+4\\.4\\s?%.*") ||
                    !linesDb.get(3).matches(".+\\s+8\\s+1\\.7\\s?%.*") ||
                    !linesDb.get(2).startsWith(ids.get(0)) || !linesDb.get(3).startsWith(ids.get(1))) {
                return CheckResult.wrong("Your Databases student list either contains incorrect data " +
                        "or is incorrectly sorted");
            }

            if (!linesSpring.get(2).matches(".+\\s+12\\s+2\\.2\\s?%.*") ||
                    !linesSpring.get(3).matches(".+\\s+11\\s+2\\.0\\s?%.*") ||
                    !linesSpring.get(2).startsWith(ids.get(0)) || !linesSpring.get(3).startsWith(ids.get(1))) {
                return CheckResult.wrong("Your Spring student list either contains incorrect data " +
                        "or is incorrectly sorted");
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 22)
        CheckResult testNotification1() {
            TestedProgram main = new TestedProgram();
            main.start();

            List<String> output = expect(main.execute("notify")).toContain(1).lines();
            if (output.stream()
                    .map(String::toLowerCase)
                    .allMatch(str -> anyMissingKeywords(str, "total", "0", "notified"))) {
                return CheckResult.wrong("Expected output was \"Total 0 students have been notified.\", " +
                        "but your output was: " + String.join("\n", output));
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 23)
        CheckResult testNotification2() {
            TestedProgram main = new TestedProgram();
            main.start();

            main.execute("add students");
            main.execute("John Doe johnd@email.net");
            main.execute("Jane Spark jspark@yahoo.com");
            main.execute("back");

            List<String> lines = expect(main.execute("list")).toContain().lines();
            List<String> ids = parseIds(lines);

            main.execute("add points");
            main.execute(String.format("%s 600 400 0 0", ids.get(0)));
            main.execute("back");

            List<String> output = expect(main.execute("notify")).toContain(7).lines();

            if (!output.get(0).toLowerCase().startsWith("to:") ||
                    !output.get(0).toLowerCase().contains("johnd@email.net") ||
                    !output.get(1).toLowerCase().startsWith("re:") ||
                    anyMissingKeywords(output.get(1), "learning", "progress") ||
                    anyMissingKeywords(output.get(2), "john", "doe", "accomplished") ||
                    !output.get(2).toLowerCase().contains("java") && !output.get(5).toLowerCase().contains("java")) {
                return CheckResult.wrong("You program should have printed the following:\nTo: johnd@email.net\n" +
                        "Re: Your Learning Progress\nHello, John Doe! You have accomplished our Java course!\n" +
                        "but your output was: \n" + output.stream().limit(3).collect(Collectors.joining("\n")));
            }

            if (!output.get(3).toLowerCase().startsWith("to:") ||
                    !output.get(3).toLowerCase().contains("johnd@email.net") ||
                    !output.get(4).toLowerCase().startsWith("re:") ||
                    anyMissingKeywords(output.get(4), "learning", "progress") ||
                    anyMissingKeywords(output.get(5), "john", "doe", "accomplished", "course") ||
                    !output.get(5).toLowerCase().contains("dsa") && !output.get(2).toLowerCase().contains("dsa")) {
                return CheckResult.wrong("You program should have printed the following:\nTo: johnd@email.net\n" +
                        "Re: Your Learning Progress\nHello, John Doe! You have accomplished our DSA course!\n" +
                        "but your output was: \n" + output.stream().limit(3).collect(Collectors.joining("\n")));
            }

            if (anyMissingKeywords(output.get(6).toLowerCase(), "total", "1", "notified")) {
                return CheckResult.wrong("Expected output was \"Total 1 student has been notified.\", but your output was: \n" +
                        String.join("\n", output));
            }

            if (output.stream().map(String::toLowerCase).anyMatch(str ->
                    str.contains("jane") || str.contains("spark") || str.contains("jspark@yahoo.com"))) {
                return CheckResult.wrong("Your notification should not mention Jane Spark");
            }

            output = expect(main.execute("notify")).toContain(1).lines();
            if (output.stream()
                    .map(String::toLowerCase)
                    .allMatch(str -> anyMissingKeywords(str, "total", "0", "notified"))) {
                return CheckResult.wrong("Expected output was \"Total 0 students have been notified\", " +
                        "but your output was: " + String.join("\n", output));
            }

            return CheckResult.correct();
        }

        private boolean anyMissingKeywords(String output, String... keywords) {
            List<String> tokens = Arrays.asList(
                    output.trim().toLowerCase().split("\\W+")
            );

            return !tokens.containsAll(Arrays.stream(keywords)
                    .map(String::toLowerCase)
                    .collect(Collectors.toList()));
        }

        private boolean incorrectString(String output, String model) {
            String normalizedOutput = output.replaceAll("\\W+", "").toLowerCase();
            String normalizedModel = model.replaceAll("\\W+", "").toLowerCase();

            return !normalizedOutput.contains(normalizedModel);
        }

        private String[] getBlankInput() {
            return new String[]{"", "  ", "\t", " \t"};
        }

        private String[] getUnknownCommands() {
            return new String[]{"abc", "quit", "  brexit ", "exi  t", "?", "break",
                    "-exit", "Ctrl+C", "exit please", ":q", "java", "spring", "dsa", "databases"};
        }

        private String[] getCorrectCredentials() {
            return new String[]{"John Smith jsmith@hotmail.com", "Anny Doolittle anny.md@mail.edu",
                    "Jean-Claude O'Connor jcda123@google.net", "Mary Emelianenko 125367at@zzz90.z9",
                    "Al Owen u15da125@a1s2f4f7.a1c2c5s4", "Robert Jemison Van de Graaff robertvdgraaff@mit.edu",
                    "Ed Eden a1@a1.a1", "na'me s-u ii@ii.ii", "n'a me su aa-b'b ab@ab.ab", "nA me 1@1.1"};
        }

        private String[][] getIncorrectCredentials() {
            return new String[][]{
                    {"", "Incorrect credentials"}, {" \t", "Incorrect credentials."},
                    {"name surname", "Incorrect credentials."},
                    {"n surname email@email.xyz", "Incorrect first name."},
                    {"'name surname email@email.xyz", "Incorrect first name."},
                    {"-name surname email@email.xyz", "Incorrect first name."},
                    {"name- surname email@email.xyz", "Incorrect first name."},
                    {"name' surname email@email.xyz", "Incorrect first name."},
                    {"nam-'e surname email@email.xyz", "Incorrect first name."},
                    {"na'-me surname email@email.xyz", "Incorrect first name."},
                    {"na--me surname email@email.xyz", "Incorrect first name."},
                    {"na''me surname email@email.xyz", "Incorrect first name."},
                    {"námé surname email@email.xyz", "Incorrect first name."},
                    {"name s email@email.xyz", "Incorrect last name."},
                    {"name -surname email@email.xyz", "Incorrect last name."},
                    {"name 'surname email@email.xyz", "Incorrect last name."},
                    {"name surnam''e email@email.xyz", "Incorrect last name."},
                    {"name surn--ame email@email.xyz", "Incorrect last name."},
                    {"name s'-urname email@email.xyz", "Incorrect last name."},
                    {"name su-'rname email@email.xyz", "Incorrect last name."},
                    {"name surname- email@email.xyz", "Incorrect last name."},
                    {"name surname' email@email.xyz", "Incorrect last name."},
                    {"name surnámé email@email.xyz", "Incorrect last name."},
                    {"name surname emailemail.xyz", "Incorrect email."},
                    {"name surname email@emailxyz", "Incorrect email."},
                    {"name surname email@e@mail.xyz", "Incorrect email."},
            };
        }

        private String[] getIncorrectPoints() {
            return new String[]{"", "-1 1 1 1", "1 1 2 A", "1 1 1", "1 1 1 1 1"};
        }

        private String[] getCorrectPoints(int n) {
            return Stream.generate(String::new)
                    .limit(n)
                    .map(it -> String.format("%d %d %d %d", nextPoint(), nextPoint(), nextPoint(), nextPoint()))
                    .toArray(String[]::new);
        }

        private int nextPoint() {
            return rnd.nextInt(10) + 1;
        }

        private List<String> parseIds(List<String> lines) {
            try {
                return lines.stream()
                        .skip(1)
                        .map(String::trim)
                        .collect(Collectors.toList());
            } catch (Exception e) {
                throw new WrongAnswer("Error occurred while parsing your output " + e.getMessage());
            }
        }

        private List<String> generateNames(int n) {
            List<String> names = List.of("Shoshana Utica", "Marisa Firman", "Gwenette Anagnos", "Charlena Girardo",
                    "Alexina Belcher", "Karee Antoinetta", "Dolley Panther", "Elysha Quinlan", "Trixie Winer",
                    "Ricki Trovillion", "Amye Uriisa", "Hedwig Wally", "Gwenette Kironde", "Jermaine Naaman",
                    "Olga Rosanne", "Annecorinne Ause", "Aurie Dorisa", "Van Fawnia", "Carmella Campman",
                    "Francesca Francis", "Elwira Florrie", "Nonna Miko", "Natka Herculie", "Roxi Hett", "Brandise Hardan",
                    "Toby Bleier", "Dalia Gleeson", "Emelia Annnora", "Beatrisa Jegar", "Barbara-Anne Chicky",
                    "Ann Agnella", "Lebbie Alabaster", "Leola Whelan", "Starlin Griz", "Anjanette Uis", "Tasha Chem");

            List<String> selectedNames = new ArrayList<>(names);
            Collections.shuffle(selectedNames);
            return selectedNames.stream().limit(n).collect(Collectors.toList());
        }

        private List<String> generateEmails(int n) {
            return IntStream.rangeClosed(1, n).mapToObj(it -> "address" + it + "@mail.com").collect(Collectors.toList());
        }

        private List<String> getRandomCredentials(int n) {
            List<String> names = generateNames(n);
            List<String> emails = generateEmails(n);
            return IntStream.range(0, n)
                    .mapToObj(it -> String.format("%s %s", names.get(it), emails.get(it)))
                    .collect(Collectors.toList());
        }
    }
  learner_created: false
- name: src/tracker/Tracker.java
  visible: true
  text: "package tracker;\n\nimport tracker.commands.*;\n\nimport java.util.ArrayList;\n\
    import java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport\
    \ static tracker.ConsoleHelper.*;\n\npublic class Tracker {\n    public Map<Integer,\
    \ Student> students = new HashMap<>();\n    public List<Course> courses = new\
    \ ArrayList<>();\n\n    public Tracker() {\n        courses.add(new Course(CourseType.JAVA));\n\
    \        courses.add(new Course(CourseType.DSA));\n        courses.add(new Course(CourseType.DB));\n\
    \        courses.add(new Course(CourseType.SPRING));\n    }\n\n    public void\
    \ init(){\n        print(GREETING);\n\n        while(true) {\n            Operation\
    \ op = getInput();\n            switch (op){\n                case EXIT: executeCommand(new\
    \ ExitCommand(this));\n                break;\n                case ADD_STUDENT:\
    \ executeCommand(new AddStudentCommand(this));\n                break;\n     \
    \           case ADD_POINTS: executeCommand(new AddPointsCommand(this));\n   \
    \             break;\n                case FIND: executeCommand(new FindCommand(this));\n\
    \                break;\n                case LIST: executeCommand(new ListCommand(this));\n\
    \                break;\n                case BACK: ConsoleHelper.print(HINT);\n\
    \                break;\n                case STATISTICS: executeCommand(new StatisticsCommand(this));\n\
    \                break;\n                case NOTIFY: executeCommand(new NotifyCommand(this));\n\
    \                break;\n                \n            }\n        }\n    }\n\n\
    \n    private void executeCommand(Command command) {\n        command.execute();\n\
    \    }\n\n    public boolean isExist(int id) {\n        for (Student s : students.values())\
    \ {\n            if (s.getId() == id) return true;\n        }\n        return\
    \ false;\n    }\n\n    public Course getCourseByType(CourseType type){\n     \
    \   return courses.stream()\n                .filter(c-> c.getName()==type)\n\
    \                .findFirst().orElse(null);\n    }\n}\n"
  learner_created: true
- name: src/tracker/Student.java
  visible: true
  text: |
    package tracker;

    import java.util.LinkedHashMap;
    import java.util.Map;
    import java.util.Objects;

    public class Student {
        private String firstName;
        private String lastName;
        private String email;
        private int id = -1;
        private Map<CourseType, Integer> coursePoints;
        private Tracker tracker;

        public Student(String firstName, String lastName, String email, int id) {
            this.firstName = firstName;
            this.lastName = lastName;
            this.email = email;
            this.id = id;
            coursePoints = new LinkedHashMap<>();
            coursePoints.put(CourseType.JAVA, 0);
            coursePoints.put(CourseType.DSA, 0);
            coursePoints.put(CourseType.DB, 0);
            coursePoints.put(CourseType.SPRING, 0);
        }

        public String getFirstName() {
            return firstName;
        }

        public void setFirstName(String firstName) {
            this.firstName = firstName;
        }

        public String getLastName() {
            return lastName;
        }

        public void setLastName(String lastName) {
            this.lastName = lastName;
        }

        public String getEmail() {
            return email;
        }

        public void setEmail(String email) {
            this.email = email;
        }

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        public int getCoursePoints(CourseType c) {
            return coursePoints.get(c);
        }

        public void updateCoursePoints(int[] points) {
            int i = 1;
            for (Map.Entry<CourseType, Integer> entry : coursePoints.entrySet()) {
                int p = entry.getValue() + points[i];
                entry.setValue(p);

                for (Course c : tracker.courses) {
                    if (c.getName() == entry.getKey()) {
                        if (points[i] > 0) {
                            c.incrementNumberOfCompletedTasks();
                            c.addStudent(this);
                            c.addTotalPoints(points[i]);
                        }
                    }
                }

                i++;
            }
        }

        public void printCoursePoints() {
            System.out.printf("%d points: Java=%d; DSA=%d; Databases=%d; Spring=%d", id,
                    coursePoints.get(CourseType.JAVA), coursePoints.get(CourseType.DSA),
                    coursePoints.get(CourseType.DB), coursePoints.get(CourseType.SPRING));
        }

        public double getCompletionPercent(CourseType course){
            return 100d*coursePoints.get(course)/course.getValue();
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Student student = (Student) o;
            return id == student.id && firstName.equals(student.firstName) && lastName.equals(student.lastName) && email.equals(student.email);
        }

        @Override
        public int hashCode() {
            return Objects.hash(firstName, lastName, email, id);
        }

        public void setTracker(Tracker tracker) {
            this.tracker = tracker;
        }
    }
  learner_created: true
- name: src/tracker/commands/NotifyCommand.java
  visible: true
  text: "package tracker.commands;\n\nimport tracker.Tracker;\n\npublic class NotifyCommand\
    \ extends Command{ \n\n    public NotifyCommand(Tracker tracker) {\n        super(tracker);\n\
    \    }\n    @Override\n    public boolean execute() {\n        return false;\n\
    \    }\n}\n"
  learner_created: true
- name: src/tracker/commands/ExitCommand.java
  visible: true
  text: |
    package tracker.commands;
    import tracker.ConsoleHelper;
    import tracker.Tracker;

    import static tracker.ConsoleHelper.*;

    public class ExitCommand extends Command{
        public ExitCommand(Tracker tracker) {
            super(tracker);
        }

        @Override
        public boolean execute() {
            print(EXIT);
            System.exit(0);
            return true;
        }
    }
  learner_created: true
- name: src/tracker/commands/StatisticsCommand.java
  visible: true
  text: |+
    package tracker.commands;

    import tracker.Course;
    import tracker.CourseType;
    import tracker.Student;
    import tracker.Tracker;


    import java.util.ArrayList;
    import java.util.Collections;
    import java.util.Comparator;
    import java.util.List;


    import static tracker.ConsoleHelper.*;

    public class StatisticsCommand extends Command {
        public StatisticsCommand(Tracker tracker) {
            super(tracker);
        }

        @Override
        public boolean execute() {
            print(STAT_PROMPT);
            generalStats();
            while (true) {
                String input = readString();
                if (input.equals("back")) {
                    break;
                }
                switch (input.toLowerCase()) {
                    case "java":
                        courseStats(tracker.getCourseByType(CourseType.JAVA));
                        break;
                    case "dsa":
                        courseStats(tracker.getCourseByType(CourseType.DSA));
                        break;
                    case "databases":
                        courseStats(tracker.getCourseByType(CourseType.DB));
                        break;
                    case "spring":
                        courseStats(tracker.getCourseByType(CourseType.SPRING));
                        break;
                    default:
                        print("Unknown course.");
                }
            }
            return false;
        }

        private void courseStats(Course course) {
            CourseType type = course.getName();
            print(type.getName() + DETAILED_STAT_RESULT);
            List<Student> students = new ArrayList<>(course.getEnrolled().stream().toList());
            if (students.isEmpty()) return;
            Comparator<Student> comparator = Comparator.comparing((Student s) -> s.getCoursePoints(type))
                    .reversed().thenComparing(Student::getId);

            students.sort(comparator);

            students
                    .forEach(s -> print(s.getId() + "\t\t" +
                            s.getCoursePoints(type) + "\t\t" +
                            df.format(s.getCompletionPercent(type)) + "%"));

        }

        private void generalStats() {
            List<Course> courses = tracker.courses;
            courses.sort(Comparator.comparingInt(Course::numberOfEnrolled));
            int maxPop = courses.get(3).numberOfEnrolled();
            int minPop = courses.get(0).numberOfEnrolled();

            if (maxPop == 0) {
                System.out.printf(STAT_RESULT, "n/a", "n/a", "n/a",
                        "n/a", "n/a", "n/a");
                return;
            }
            List<Course> popular = courses.stream().filter(c -> c.numberOfEnrolled() == maxPop).toList();
            List<Course> unpopular = new ArrayList<>();
            if (maxPop != minPop) {
                unpopular = courses.stream().filter(c -> c.numberOfEnrolled() == minPop).toList();
            }

            courses.sort(Comparator.comparingInt(Course::getNumberOfCompletedTasks));
            int maxAct = courses.get(3).getNumberOfCompletedTasks();
            int minAct = courses.get(0).getNumberOfCompletedTasks();

            List<Course> mostActive = courses.stream().filter(c -> c.getNumberOfCompletedTasks() == maxAct).toList();
            List<Course> leastActive = new ArrayList<>();
            if (maxAct != minAct) {
                leastActive = courses.stream().filter(c -> c.getNumberOfCompletedTasks() == minAct).toList();
            }


            courses.sort(Comparator.comparingDouble(Course::getAverageGrade));
            double maxAv = courses.get(3).getAverageGrade();
            double minAv = courses.get(0).getAverageGrade();

            List<Course> hardest = new ArrayList<>();
            List<Course> easiest = courses.stream().filter(c -> c.getAverageGrade() == maxAv).toList();
            if (maxAv != minAv) {
                hardest = courses.stream().filter(c -> c.getAverageGrade() == minAv).toList();
            }

            System.out.printf(STAT_RESULT, printList(popular), printList(unpopular),
                    printList(mostActive), printList(leastActive),
                    printList(easiest), printList(hardest));
        }
    }

  learner_created: true
- name: src/tracker/Formatter.java
  visible: true
  text: |
    package tracker;

    public class Formatter {
        public static final String NAME_PATTERN = "^[a-zA-Z]+(([\\'\\,\\.\\- ][a-zA-Z ])?[a-zA-Z]*)*";
        public static final String EMAIL_PATTERN = "^[a-zA-Z0-9_\\-\\.]+@{1}\\w+\\.{1}\\w+";
        public static final String POINTS_PATTERN = "^(\\d+\\s){4}\\d+$";
        public static final String ID_PATTERN = "^\\d+$";


        public static boolean isValid(String input, String pattern){
           return input.matches(pattern);
       }

    }
  learner_created: true
- name: src/tracker/Operation.java
  visible: true
  text: |
    package tracker;

    public enum Operation {
        EXIT,
        BACK,
        ADD_STUDENT,
        LIST,
        FIND,
        ADD_POINTS,
        STATISTICS,
        NOTIFY,
        ERROR
    }
  learner_created: true
- name: src/tracker/commands/AddStudentCommand.java
  visible: true
  text: |
    package tracker.commands;


    import tracker.Student;
    import tracker.Tracker;

    import static tracker.ConsoleHelper.*;
    import static tracker.Formatter.*;

    public class AddStudentCommand extends Command {

        public AddStudentCommand(Tracker tracker) {
            super(tracker);
        }

        @Override
        public boolean execute() {
            int count = 0;

            print(ENTER_CRED);
            while (true) {
                String[] input = readString().split(" ");
                if (input[0].equals("back")) {
                    break;
                }

                if (input.length < 3) {
                    print(ADD_FAIL);
                } else {
                    String firstName = input[0];
                    String email = input[input.length - 1];
                    String lastName = "";
                    for (int i = 1; i < input.length - 1; i++) {
                        lastName += input[i] + " ";
                    }
                    lastName = lastName.trim();

                    if (firstName.length() < 2 || !isValid(firstName, NAME_PATTERN)) {
                        print(FIRSTNAME_FAIL);
                    } else if (lastName.length() < 2 || !isValid(lastName, NAME_PATTERN)) {
                        print(LASTNAME_FAIL);
                    } else if (!isValid(email, EMAIL_PATTERN)) {
                        print(EMAIL_FAIL);
                    } else if (isTaken(email)) {
                        print(EMAIL_EXIST);
                    } else {
                        int id = 0;
                        while (tracker.students.containsKey(id)) {
                            id++;
                        }
                        Student student = new Student(firstName, lastName, email, id);
                        student.setTracker(tracker);
                        tracker.students.put(id, student);

                        print(ADD_SUCCESS);
                        count++;
                    }
                }
            }
            print(ADD_TOTAL, count);
            return false;
        }

        private boolean isTaken(String email) {
            for (Student s : tracker.students.values()) {
                if (s.getEmail().equals(email)) return true;
            }
            return false;
        }
    }
  learner_created: true
- name: src/tracker/commands/AddPointsCommand.java
  visible: true
  text: |
    package tracker.commands;

    import tracker.Student;
    import tracker.Tracker;

    import static tracker.ConsoleHelper.*;
    import static tracker.Formatter.*;

    public class AddPointsCommand extends Command {
        public AddPointsCommand(Tracker tracker) {
            super(tracker);
        }

        @Override
        public boolean execute() {
            print(ADD_POINTS);

            while (true) {
                String input = readString();
                if (input.split(" ")[0].equals("back")) {
                    break;
                }
                String[] splitted = input.split(" ");
                if(!isValid(splitted[0], ID_PATTERN)) {
                    print(FIND_FAIL + splitted[0]);
                }

                else if (!isValid(input, POINTS_PATTERN)) {
                    print(ADD_POINTS_FAIL);
                } else {
                    int[] points = new int[5];

                    int i = 0;
                    for (String s : input.split(" ")) {
                        points[i] = Integer.parseInt(s);
                        i++;
                    }

                    if (!tracker.isExist(points[0])) print(FIND_FAIL + points[0]);
                    else {
                        Student student = tracker.students.get(points[0]);
                        student.updateCoursePoints(points);
                        print(ADD_POINTS_SUCCESS);
                    }
                }
            }
            return false;
        }

    }
  learner_created: true
- name: src/tracker/commands/ListCommand.java
  visible: true
  text: |
    package tracker.commands;

    import tracker.Tracker;
    import static tracker.ConsoleHelper.*;

    public class ListCommand extends Command{
        public ListCommand(Tracker tracker) {
            super(tracker);
        }

        @Override
        public boolean execute() {
            if(tracker.students.isEmpty()) {
                print(LIST_FAIL);
            }
            else {
                print(LIST);
                tracker.students
                        .values()
                        .forEach(s->print(String.valueOf(s.getId())));
            }
            return false;
        }
    }
  learner_created: true
- name: src/tracker/ConsoleHelper.java
  visible: true
  text: "package tracker;\n\nimport java.math.RoundingMode;\nimport java.text.DecimalFormat;\n\
    import java.text.NumberFormat;\nimport java.util.List;\nimport java.util.Locale;\n\
    import java.util.Scanner;\n\npublic class ConsoleHelper {\n    public static final\
    \ Scanner scanner = new Scanner(System.in);\n    public static final String GREETING\
    \ = \"Learning Progress Tracker\";\n    public static final String EXIT = \"Bye!\"\
    ;\n    public static final String EMPTY = \"No input\";\n    public static final\
    \ String UNKNOWN = \"Unknown command!\";\n    public static final String HINT\
    \ = \"Enter 'exit' to exit the program.\";\n    public static final String ENTER_CRED\
    \ = \"Enter student credentials or 'back' to return:\";\n    public static final\
    \ String ADD_SUCCESS = \"The student has been added.\";\n    public static final\
    \ String ADD_FAIL = \"Incorrect credentials.\";\n    public static final String\
    \ ADD_TOTAL = \"Total %d students have been added.\\n\";\n    public static final\
    \ String FIRSTNAME_FAIL = \"Incorrect first name.\";\n    public static final\
    \ String LASTNAME_FAIL = \"Incorrect last name.\";\n    public static final String\
    \ EMAIL_FAIL = \"Incorrect email.\";\n    public static final String EMAIL_EXIST\
    \ = \"This email is already taken.\";\n    public static final String ADD_POINTS\
    \ = \"Enter an id and points or 'back' to return:\";\n    public static final\
    \ String ADD_POINTS_SUCCESS = \"Points updated.\";\n    public static final String\
    \ ADD_POINTS_FAIL = \"Incorrect points format.\";\n    public static final String\
    \ FIND = \"Enter an id or 'back' to return:\";\n    public static final String\
    \ FIND_FAIL = \"No student is found for id=\";\n    public static final String\
    \ LIST = \"Students:\";\n    public static final String LIST_FAIL = \"No students\
    \ found\";\n    public static final String STAT_PROMPT = \"Type the name of a\
    \ course to see details or 'back' to quit:\";\n    public static final String\
    \ STAT_RESULT = \"Most popular: %s\\n\" +\n            \"Least popular: %s\\n\"\
    \ +\n            \"Highest activity: %s\\n\" +\n            \"Lowest activity:\
    \ %s\\n\" +\n            \"Easiest course: %s\\n\" +\n            \"Hardest course:\
    \ %s\\n\";\n    public static final String DETAILED_STAT_RESULT = \"\\nid    points\
    \    completed\";\n    public static final DecimalFormat df;\n    \n    static{\n\
    \        df = (DecimalFormat) NumberFormat.getNumberInstance(Locale.ENGLISH);\n\
    \        df.setRoundingMode(RoundingMode.HALF_UP);\n        df.applyPattern(\"\
    #0.0\");\n    }\n\n    public static void print(String message){\n        System.out.println(message);\n\
    \    }\n\n    public static void print(String message, int n){\n        System.out.printf(message,\
    \ n);\n    }\n\n    public static String printList(List<?> list) {\n        if\
    \ (list.isEmpty()) return \"n/a\";\n        StringBuilder sb = new StringBuilder();\n\
    \        for (Object o : list){\n            sb.append(o.toString()).append(\"\
    , \");\n        }\n       return sb.substring(0, sb.length()-2);\n    }\n\n  \
    \  public static Operation getInput(){\n        String in = scanner.nextLine();\n\
    \n        if(in.isEmpty() || in.matches(\"\\\\s+\")) {\n            print(EMPTY);\n\
    \            return Operation.ERROR;\n        }\n        switch (in){\n      \
    \      case \"exit\": return Operation.EXIT;\n            case \"back\": return\
    \ Operation.BACK;\n            case \"add students\": return Operation.ADD_STUDENT;\n\
    \            case \"list\": return Operation.LIST;\n            case \"add points\"\
    : return Operation.ADD_POINTS;\n            case \"find\": return Operation.FIND;\n\
    \            case \"statistics\": return Operation.STATISTICS;\n            case\
    \ \"notify\":return Operation.NOTIFY;\n            default: print(UNKNOWN);\n\
    \                return Operation.ERROR;\n        }\n    }\n    public static\
    \ String readString(){\n        return scanner.nextLine();\n    }\n\n}\n"
  learner_created: true
- name: src/tracker/commands/FindCommand.java
  visible: true
  text: |
    package tracker.commands;

    import tracker.Tracker;

    import static tracker.ConsoleHelper.*;
    import static tracker.Formatter.*;

    public class FindCommand extends Command {
        public FindCommand(Tracker tracker) {
            super(tracker);
        }

        @Override
        public boolean execute() {
            print(FIND);
            while (true) {
                String input = readString();
                if (input.equals("back")) {
                    break;
                }
                if (!isValid(input, ID_PATTERN)) {
                    print(FIND_FAIL + input.split(" ")[0]);
                } else {
                    int id = Integer.parseInt(input);

                    if (!tracker.isExist(id)) {
                        print(FIND_FAIL, id);
                    } else {
                        tracker.students.get(id).printCoursePoints();
                    }
                }
            }
            return false;
        }
    }
  learner_created: true
- name: src/tracker/Course.java
  visible: true
  text: |
    package tracker;

    import java.util.HashSet;
    import java.util.LinkedHashSet;
    import java.util.Set;

    public class Course {
        private CourseType name;
        private int totalPoints;
        private Set<Student> enrolled;
        private int numberOfCompletedTasks;

        public Course(CourseType name) {
            this.name = name;
            enrolled = new LinkedHashSet<>();
        }

        public CourseType getName() {
            return name;
        }

        public int getNumberOfCompletedTasks() {
            return numberOfCompletedTasks;
        }

        public void incrementNumberOfCompletedTasks(){
            numberOfCompletedTasks++;
        }

        public void addStudent(Student student){
            enrolled.add(student);
        }

        public Set<Student> getEnrolled() {
            return enrolled;
        }

        public int numberOfEnrolled(){
            return enrolled.size();
        }

        @Override
        public String toString() {
            return name.toString();
        }

        public void addTotalPoints(int points){
            totalPoints+=points;
        }

        public double getAverageGrade(){
            return (double) totalPoints/numberOfCompletedTasks;
        }
    }
  learner_created: true
- name: src/tracker/commands/Command.java
  visible: true
  text: |
    package tracker.commands;


    import tracker.Tracker;

    public abstract class Command {
        public Tracker tracker;
        public Command(Tracker tracker) {
            this.tracker = tracker;
        }

        public abstract boolean execute();
    }
  learner_created: true
- name: src/tracker/CourseType.java
  visible: true
  text: |
    package tracker;


    public enum CourseType {
        JAVA("Java", 600),
        DSA("DSA", 400),
        DB("Databases", 480),
        SPRING("Spring", 550);

        private String name;
        private int value;

        CourseType(String name, int value) {
            this.name = name;
            this.value = value;
        }

        public int getValue() {
            return value;
        }

        public String getName() {
            return name;
        }



        @Override
        public String toString() {
            return  name;
        }
    }
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/14400#comment
status: Solved
feedback:
  message: Well done! You've finished the project. Select a new project on <a href="https://hyperskill.org/projects">JetBrains
    Academy</a> to continue learning.
  time: Sat, 19 Feb 2022 19:46:10 UTC
record: -1
